module chapter11.Code11 where

import frege.test.QuickCheck
--import Data.Int

main :: IO ()
main = println "Code11"

-- 11.5 Data constructors and values

data PugType = PugData
data HuskyType a = HuskyData
data DogueDeBordeaux doge = DogueDeBordeaux doge

myPug = PugData :: PugType

myHusky :: HuskyType a
myHusky = HuskyData

myOtherHusky :: Num a => HuskyType a
myOtherHusky = HuskyData

myOtherOtherHusky :: HuskyType [[[[Int]]]]
myOtherOtherHusky = HuskyData

myDoge :: DogueDeBordeaux Int
myDoge = DogueDeBordeaux 10

-- FREGE kind error
--data Doggies a = Husky a | Mastiff a
--derive Eq Doggies
--derive Show Doggies


-- Exercises: Dog Types
-- 1. Is Doggies a type constructor or a data constructor?
-- type constructor
-- 2. What is the kind of Doggies?
-- FREGE :k not possible in frepl
-- 3. What is the kind of Doggies String?
-- 4. What is the type of Husky 10?
-- 5. What is the type of Husky (10 :: Integer)?
-- 6. What is the type of Mastiff "Scooby Doo"?
-- 7. Is DogueDeBordeaux a type constructor or a data constructor?
-- 8. What is the type of DogueDeBordeaux?
-- 9. What is the type of DogueDeBordeaux "doggie!"

-- 11.6 What’s a type and what’s data?

data Price = Price Integer
derive Eq Price
derive Show Price

data Manufacturer = Mini | Mazda | Tata
derive Eq Manufacturer
derive Show Manufacturer

data Airline =
    PapuAir
    | CatapultsR'Us
    | TakeYourChancesUnited
derive Eq Airline
derive Show Airline

data Vehicle = Car Manufacturer Price
    | Plane Airline
derive Eq Vehicle
derive Show Vehicle

-- Exercises: Vehicles

myCar = Car Mini (Price 14000)
urCar = Car Mazda (Price 20000)
clownCar = Car Tata (Price 7000)
doge = Plane PapuAir

carList = [myCar, urCar, clownCar]

-- 1.
-- :t myCar
-- myCar :: Vehicle

-- 2.
isCar :: Vehicle -> Bool
isCar (Car _ _ ) = True
isCar _ = False

isPlane :: Vehicle -> Bool
isPlane (Plane _) = True
isPlane _ = False

areCars :: [Vehicle] -> [Bool]
areCars = map isCar

-- 3.
getManu :: Vehicle -> Manufacturer
getManu (Car manufacturer price ) = manufacturer

-- 4.
-- Haskell: Non-exhaustive patterns in function getManu
-- Frege: function pattern is refutable, consider adding a case for Vehicle.Plane_

-- 5.
data Size = Size Integer
derive Eq Size
derive Show Size

data Vehicle' = Car' Manufacturer Price | Plane' Airline Size
derive Eq Vehicle'
derive Show Vehicle'

isPlane' :: Vehicle' -> Bool
isPlane' (Plane' _ _) = True
isPlane' _ = False

doge' = Plane' PapuAir (Size 22)

-- 11.7 Data constructor arities

-- nullary
data Example0 = Example0
derive Eq Example0
derive Show Example0

-- unary
data Example1 = Example1 Int
derive Eq Example1
derive Show Example1

-- product of Int and String
data Example2 = Example2 Int String
derive Eq Example2
derive Show Example2


data MyType = MyVal Int
derive Eq MyType
derive Show MyType

-- 11.8 What makes these datatypes algebraic?

-- Exercises: Cardinality
-- TODO
-- 1. 
-- data PugType = PugData
-- cardinality = 1

-- 2.
-- data Airline = PapuAir | CatapultsR'Us | TakeYourChancesUnited
-- cardinality = 3

-- 3. Given what we know about Int8, what’s the cardinality of Int16?
-- cardinality = 2^16 (65536)

-- 4. Use the REPL and maxBound and minBound to examine Int and Integer. What can you say about the cardinality of those types?

-- 5. Extra credit (impress your friends!): What’s the connection between the 8 in Int8 and that type’s cardinality of 256?
-- 2^x where x is the number of bits

-- Simple datatypes with nullary data constructors
data Example = MakeExample
derive Show Example

-- Exercises: For Example
-- TODO

-- Unary constructors
-- data Goats = Goats Int deriving (Eq, Show)

-- 11.9 newtype

tooManyGoats :: Int -> Bool
tooManyGoats n = n > 42

newtype Goats' = Goats' Int
derive Eq Goats'
derive Show Goats'

newtype Cows = Cows Int
derive Eq Cows
derive Show Cows

tooManyGoats' :: Goats' -> Bool
tooManyGoats' (Goats' n) = n > 42

class TooMany a where
    tooMany :: a -> Bool

instance TooMany Int where
    tooMany n = n > 42


newtype Goats1 = Goats1 Int
derive Show Goats1

instance TooMany1 Goats1 where
    tooMany1 (Goats1 n) = n > 43

class TooMany1 a where
    tooMany1 :: a -> Bool

instance TooMany1 Int where
    tooMany1 n = n > 42

newtype Goats2 = Goats2 Int
derive Eq Goats2
derive Show Goats2

instance TooMany1 Goats2 where
    tooMany1 (Goats2 n) = tooMany1 n
        

-- TODO Pragma

-- Exercises: Logic Goats
-- TODO

-- 11.10 Sum types
-- Exercises: Pity the Bool

-- 1.
data BigSmall = Big Bool | Small Bool
derive Eq BigSmall
derive Show BigSmall

-- 2.
-- FREGE not possible?
 -- bring Int8 in scope
--data NumberOrBool = Numba Int8 | BoolyBool Bool
--derive Eq NumberOrBool
--derive Show NumberOrBool
-- parentheses due to syntactic -- collision between (-) minus -- and the negate function
--myNumba = Numba (-128)


-- 11.11 Product types
data QuantumBool = QuantumTrue | QuantumFalse | QuantumBoth
derive Eq QuantumBool
derive Show QuantumBool

data TwoQs = MkTwoQs QuantumBool QuantumBool
derive Eq TwoQs
derive Show TwoQs

type TwoQs1 = (QuantumBool, QuantumBool)

data Person = MkPerson String Int
derive Eq Person
derive Show Person

-- sample data
jm = MkPerson "julie" 108 
ca = MkPerson "chris" 16

namae :: Person -> String
namae (MkPerson s _) = s

data Person1 =
    Person1 { name :: String , age :: Int }
derive Eq Person1
derive Show Person1



-- 11.12 Normal form

type AuthorName = String

data Author = Fiction AuthorName 
            | Nonfiction AuthorName 
derive Eq Author
derive Show Author

data Expr =
    Number Int
    | Add Expr Expr
    | Minus Expr
    | Mult Expr Expr
    | Divide Expr Expr

type Number' = Int
type Add' = (Expr, Expr)
type Minus' = Expr
type Mult' = (Expr, Expr)
type Divide' = (Expr, Expr)

type Expr' =
    Either Number'
    (Either Add'
    (Either Minus'
    (Either Mult' Divide')))

-- Exercises: How Does Your Garden Grow?

data FlowerType = Gardenia
    | Daisy
    | Rose
    | Lilac
derive Show FlowerType

type Gardener = String

data Garden =
    Garden Gardener FlowerType
derive Show Garden

-- 11.13 Constructing and deconstructing values

data GuessWhat = Chickenbutt
derive Eq GuessWhat
derive Show GuessWhat


-- TODO Compiler errors
data Id a = MkId a
--derive Eq Id
--derive Show Id

data Product a b = Product a b
--derive Eq Product
--derive Show Product

data Sum a b =
    First a
    | Second b
--derive Eq Sum
--derive Show Sum


data RecordProduct a b =
    RecordProduct { pfirst :: a
                  , psecond :: b }
--derive Eq RecordProduct
--derive Show RecordProduct



newtype NumCow = NumCow Int
derive Eq NumCow
derive Show NumCow

newtype NumPig =
    NumPig Int
derive Eq NumPig
derive Show NumPig

data Farmhouse = Farmhouse NumCow NumPig
derive Eq Farmhouse
derive Show Farmhouse

type Farmhouse' = Product NumCow NumPig

newtype NumSheep = NumSheep Int
derive Eq NumSheep
derive Show NumSheep
    
data BigFarmhouse = BigFarmhouse NumCow NumPig NumSheep
derive Eq BigFarmhouse
derive Show BigFarmhouse

type BigFarmhouse' =
    Product NumCow (Product NumPig NumSheep)

type AName = String
type Age = Int
type LovesMud = Bool

type PoundsOfWool = Int

data CowInfo = CowInfo AName Age
derive Eq CowInfo
derive Show CowInfo

data PigInfo = PigInfo AName Age LovesMud
derive Eq PigInfo
derive Show PigInfo

data SheepInfo = SheepInfo AName Age PoundsOfWool
derive Eq SheepInfo
derive Show SheepInfo

data Animal =
    Cow CowInfo
    | Pig PigInfo
    | Sheep SheepInfo
derive Eq Animal
derive Show Animal

-- Alternately
type Animal' =
    Sum CowInfo (Sum PigInfo SheepInfo)

    -- Constructing values

trivialValue :: GuessWhat
trivialValue = Chickenbutt

data Id' a  = MkId' a
--derive Eq Id'
--derive Show Id'

-- note:
-- MkId :: a -> Id a

idInt :: Id' Integer
idInt = MkId' 10

type Awesome = Bool
type PersonName = String

person :: Product PersonName Awesome
person = Product "Simon" True

data Sum' a b =
    First' a
    | Second' b
--derive Eq Sum'
--derive Show Sum'

-- data Twitter =
--     Twitter deriving (Eq, Show)
-- 
-- data AskFm =
--     AskFm deriving (Eq, Show)

-- socialNetwork :: Sum Twitter AskFm
-- socialNetwork = First Twitter

data SocialNetwork =
      Twitter
    | AskFm
derive Eq SocialNetwork
derive Show SocialNetwork

type Twitter = String
type AskFm = String

twitter :: Sum Twitter AskFm
twitter = First "Twitter"

askfm :: Sum Twitter AskFm
askfm = First "AskFm"


myRecord :: RecordProduct Integer Float
myRecord = RecordProduct 42 0.00001

myRecord' :: RecordProduct Integer Float
myRecord' =
    RecordProduct { pfirst = 42
                  , psecond = 0.00001 }

data OperatingSystem =
    GnuPlusLinux
    | OpenBSDPlusNevermindJustBSDStill
    | Mac
    | Windows
derive Eq OperatingSystem
derive Show OperatingSystem

data ProgLang =
    Haskell
    | Agda
    | Idris
    | PureScript
derive Eq ProgLang
derive Show ProgLang

data Programmer =
    Programmer { os :: OperatingSystem
                , lang :: ProgLang }
derive Eq Programmer
derive Show Programmer

nineToFive :: Programmer
nineToFive = Programmer { os = Mac
                        , lang = Haskell }

-- We can reorder stuff
-- when we use record syntax

feelingWizardly :: Programmer
feelingWizardly =
    Programmer { lang = Agda
                , os = GnuPlusLinux }

-- Exercise: Programmers

allOperatingSystems :: [OperatingSystem]
allOperatingSystems =
    [ GnuPlusLinux
    , OpenBSDPlusNevermindJustBSDStill
    , Mac
    , Windows
    ]

quickTestAllOperatingSystems = once $ (length allOperatingSystems == 4)

allLanguages :: [ProgLang]
allLanguages =
    [Haskell, Agda, Idris, PureScript]
    
quickTestAllLanguages = once $ (length allLanguages == 4)


allProgrammers :: [Programmer]
allProgrammers = [Programmer { lang = lang, os = os } | lang <- allLanguages, os <- allOperatingSystems]

quickTestAllProgrammers = once $ (length allProgrammers == 16)

-- Accidental bottoms from records

-- Works the same as if
-- we'd used record syntax.
data ThereYet = There Float Int Bool
derive Eq ThereYet
derive Show ThereYet
    
nope :: Float -> Int -> Bool -> ThereYet
nope = undefined

notYet :: Int -> Bool -> ThereYet
notYet = nope 25.5

notQuite :: Bool -> ThereYet
notQuite = notYet 10

yusssss :: ThereYet
yusssss = notQuite False

-- Notice the way our types progressed.
-- There ::     Float -> Int -> Bool -> ThereYet
-- notYet ::             Int -> Bool -> ThereYet
-- notQuite ::                  Bool -> ThereYet
-- yusssss ::                           ThereYet

-- Deconstructing values

newtype Name = Name String
derive Show Name
newtype Acres = Acres Int
derive Show Acres

-- FarmerType is a Sum
data FarmerType = DairyFarmer
    | WheatFarmer
    | SoybeanFarmer
derive Show FarmerType

-- Farmer is a plain ole product of
-- Name, Acres, and FarmerType
data Farmer = Farmer Name Acres FarmerType
derive Show Farmer

isDairyFarmer :: Farmer -> Bool
isDairyFarmer (Farmer _ _ DairyFarmer) =
    True
isDairyFarmer _ =
    False

data FarmerRec =
    FarmerRec { name :: Name
              , acres :: Acres
              , farmerType :: FarmerType }
derive Show FarmerRec

-- TODO FREGE CHECK
--isDairyFarmerRec :: FarmerRec -> Bool
--isDairyFarmerRec farmer =
--    case farmerType farmer of
--        DairyFarmer -> True
--        _           -> False

-- Accidental bottoms from records

-- Don't.
-- data Automobile = Null
--     | Car { make :: String
--            , model :: String
--            , year :: Integer }
--            deriving (Eq, Show)


-- Split out the record/product
data Car1 = Car1 { make :: String
                , model :: String
                , year :: Integer }
derive Eq Car1
derive Show Car1

-- The Null is still not great, but
-- we're leaving it in to make a point
data Automobile = Null
                | Automobile Car1
derive Eq Automobile
derive Show Automobile

-- 11.14 Function type is exponential
data Quantum =
    Yes
    | No
    | Both
derive Eq Quantum
derive Show Quantum

-- arithmetic of sum types

-- 3 + 3
quantSum1 :: Either Quantum Quantum
quantSum1 = Right Yes
quantSum2 :: Either Quantum Quantum
quantSum2 = Right No
quantSum3 :: Either Quantum Quantum
quantSum3 = Right Both
quantSum4 :: Either Quantum Quantum
quantSum4 = Left Yes
quantSum5 :: Either Quantum Quantum
quantSum5 = Left No
quantSum6 :: Either Quantum Quantum
quantSum6 = Left Both

-- arithmetic of product types

-- 3 * 3
quantProd1 :: (Quantum, Quantum)
quantProd1 = (Yes, Yes)
quantProd2 :: (Quantum, Quantum)
quantProd2 = (Yes, No)
quantProd3 :: (Quantum, Quantum)
quantProd3 = (Yes, Both)
quantProd4 :: (Quantum, Quantum)
quantProd4 = (No, Yes)
quantProd5 :: (Quantum, Quantum)
quantProd5 = (No, No)
quantProd6 :: (Quantum, Quantum)
quantProd6 = (No, Both)
quantProd7 :: (Quantum, Quantum)
quantProd7 = (Both, Yes)
quantProd8 :: (Quantum, Quantum)
quantProd8 = (Both, No)
quantProd9 :: (Quantum, Quantum)
quantProd9 = (Both, Both)

-- arithmetic of function types

-- 3 ^ 3
quantFlip1 :: Quantum -> Quantum
quantFlip1 Yes = Yes
quantFlip1 No = Yes
quantFlip1 Both = Yes
quantFlip2 :: Quantum -> Quantum
quantFlip2 Yes = Yes
quantFlip2 No = Yes
quantFlip2 Both = No
quantFlip3 :: Quantum -> Quantum
quantFlip3 Yes = Yes
quantFlip3 No = Yes
quantFlip3 Both = Both
quantFlip4 :: Quantum -> Quantum
quantFlip4 Yes = Yes
quantFlip4 No = No
quantFlip4 Both = Yes
quantFlip5 :: Quantum -> Quantum
quantFlip5 Yes = Yes
quantFlip5 No = Both
quantFlip5 Both = Yes
quantFlip6 :: Quantum -> Quantum
quantFlip6 Yes = No
quantFlip6 No = Yes
quantFlip6 Both = Yes
quantFlip7 :: Quantum -> Quantum
quantFlip7 Yes = Both
quantFlip7 No = Yes
quantFlip7 Both = Yes
quantFlip8 :: Quantum -> Quantum
quantFlip8 Yes = Both
quantFlip8 No = Yes
quantFlip8 Both = No
quantFlip9 :: Quantum -> Quantum
quantFlip9 Yes = Both
quantFlip9 No = No
quantFlip9 Both = No
quantFlip10 :: Quantum -> Quantum
quantFlip10 Yes = Both
quantFlip10 No = No
quantFlip10 Both = Both
quantFlip11 :: Quantum -> Quantum
quantFlip11 Yes = Both
quantFlip11 No = No
quantFlip11 Both = Yes
quantFlip12 :: Quantum -> Quantum
quantFlip12 Yes = Both
quantFlip12 No = Both
quantFlip12 Both = No
quantFlip13 :: Quantum -> Quantum
quantFlip13 Yes = No
quantFlip13 No = Both
quantFlip13 Both = Both
quantFlip14 :: Quantum -> Quantum
quantFlip14 Yes = Both
quantFlip14 No = Both
quantFlip14 Both = Yes
quantFlip15 :: Quantum -> Quantum
quantFlip15 Yes = Yes
quantFlip15 No = Both
quantFlip15 Both = Both
quantFlip16 :: Quantum -> Quantum
quantFlip16 Yes = No
quantFlip16 No = No
quantFlip16 Both = No
quantFlip17 :: Quantum -> Quantum
quantFlip17 Yes = Both
quantFlip17 No = Both
quantFlip17 Both = Both
quantFlip18 :: Quantum -> Quantum
quantFlip18 Yes = Yes
quantFlip18 No = No
quantFlip18 Both = No
quantFlip19 :: Quantum -> Quantum
quantFlip19 Yes = Yes
quantFlip19 No = No
quantFlip19 Both = Both
quantFlip20 :: Quantum -> Quantum
quantFlip20 Yes = Yes
quantFlip20 No = Both
quantFlip20 Both = No
quantFlip21 :: Quantum -> Quantum
quantFlip21 Yes = No
quantFlip21 No = Yes
quantFlip21 Both = No
quantFlip22 :: Quantum -> Quantum
quantFlip22 Yes = No
quantFlip22 No = Yes
quantFlip22 Both = Both
quantFlip23 :: Quantum -> Quantum
quantFlip23 Yes = No
quantFlip23 No = Both
quantFlip23 Both = Yes
quantFlip24 :: Quantum -> Quantum
quantFlip24 Yes = No
quantFlip24 No = No
quantFlip24 Both = Yes
quantFlip25 :: Quantum -> Quantum
quantFlip25 Yes = No
quantFlip25 No = No
quantFlip25 Both = Both
quantFlip26 :: Quantum -> Quantum
quantFlip26 Yes = No
quantFlip26 No = Both
quantFlip26 Both = No
quantFlip27 :: Quantum -> Quantum
quantFlip27 Yes = Both
quantFlip27 No = Yes
quantFlip27 Both = Both

-- Exponentiation in what order?

convert1 :: Quantum -> Bool
convert1 Yes = True
convert1 No = True
convert1 Both = True
convert2 :: Quantum -> Bool
convert2 Yes = True
convert2 No = True
convert2 Both = False
convert3 :: Quantum -> Bool
convert3 Yes = True
convert3 No = False
convert3 Both = True
convert4 :: Quantum -> Bool
convert4 Yes = True
convert4 No = False
convert4 Both = False
convert5 :: Quantum -> Bool
convert5 Yes = False
convert5 No = True
convert5 Both = True
convert6 :: Quantum -> Bool
convert6 Yes = False
convert6 No = True
convert6 Both = False
convert7 :: Quantum -> Bool
convert7 Yes = False
convert7 No = False
convert7 Both = True
convert8 :: Quantum -> Bool
convert8 Yes = False
convert8 No = False
convert8 Both = False

-- According to the equality of a -> b and 𝑏^a there should be 2^3 or 8
-- implementations of this function. Does this hold? Write it out and
-- prove it for yourself.

-- Exercises: The Quad
-- Determine how many unique inhabitants each type has.
-- 1.
data Quad =
    One
    | Two
    | Three
    | Four
derive Eq Quad
derive Show Quad
   
 -- how many different forms can this take?
eQuad :: Either Quad Quad
eQuad = undefined
-- (sum type) 4 + 4 = 8

-- 2.
prodQuad :: (Quad, Quad)
prodQuad = undefined
-- (product type) 4 * 4 = 16


-- 3.
funcQuad :: Quad -> Quad
funcQuad = undefined
-- (function type) 4 ^ 4 = 256

-- 4.
prodTBool :: (Bool, Bool, Bool)
prodTBool = undefined
-- (product type) 2 * 2 * 2 = 8

-- 5.
gTwo :: Bool -> Bool -> Bool
gTwo = undefined
-- (function type) 2 ^ 2 ^ 2 = 16

-- 6. Hint: 5 digit number
fTwo :: Bool -> Quad -> Quad
fTwo = undefined
-- TODO


-- 11.15 Higher-kinded datatypes

-- identical to (a, b, c, d)
data Silly a b c d = MkSilly a b c d
--derive Show Silly
-- TODO

-- TODO 

-- data EsResultFound a =
--     EsResultFound { _version :: DocVersion
--               , _source :: a
--               } deriving (Eq, Show)

-- TODO 
-- instance (FromJSON a) =>
--    FromJSON (EsResultFound a) where
--        parseJSON (Object v) =
--                EsResultFound
--            <$> v .: "_version"
--            <*> v .: "_source"
--        parseJSON _ = empty

-- TODO
-- 11.17 Binary Tree
data BinaryTree a =
      Leaf
    | Node (BinaryTree a) a (BinaryTree a)
--derive Eq BinaryTree
--derive Show BinaryTree
--derive Ord BinaryTree

insert' :: Ord a
            => a
            -> BinaryTree a
            -> BinaryTree a
insert' b Leaf = Node Leaf b Leaf
insert' b (Node left a right)
    | b == a = Node left a right
    | b < a = Node (insert' b left) a right
    | b > a = Node left a (insert' b right)

-- Write map for BinaryTree

mapTree :: (a -> b)
            -> BinaryTree a
            -> BinaryTree b
mapTree _ Leaf = Leaf
mapTree f (Node left a right) =
    Node (mapTree f left) (f a) (mapTree f right)

testTree' :: BinaryTree Integer
testTree' =
    Node (Node Leaf 3 Leaf)
         1
         (Node Leaf 4 Leaf)
         
mapExpected :: BinaryTree Integer
mapExpected =
    Node (Node Leaf 4 Leaf)
         2
         (Node Leaf 5 Leaf)

-- acceptance test for mapTree
--mapOkay =
--    if mapTree (+1) testTree' == mapExpected
--    then print "yup okay!"
--    else error "test failed!"


-- Convert binary trees to lists
preorder :: BinaryTree a -> [a]
preorder Leaf = []
preorder (Node left a right) = [a] ++ preorder left ++ preorder right

inorder :: BinaryTree a -> [a]
inorder Leaf = []
inorder (Node left a right) = inorder left ++ [a] ++ inorder right

postorder :: BinaryTree a -> [a]
postorder Leaf = []
postorder (Node left a right) = postorder left ++ postorder right ++ [a]

testTree :: BinaryTree Integer
testTree =
    Node (Node Leaf 1 Leaf)
         2
         (Node Leaf 3 Leaf)

testPreorder :: IO ()
testPreorder =
    if preorder testTree == [2, 1, 3]
    then putStrLn "Preorder fine!"
    else putStrLn "Bad news bears."

quickTestPreorder = once $ preorder testTree == [2, 1, 3]

testInorder :: IO ()
testInorder =
    if inorder testTree == [1, 2, 3]
    then putStrLn "Inorder fine!"
    else putStrLn "Bad news bears."

quickTestInorder = once $ inorder testTree == [1, 2, 3]

testPostorder :: IO ()
testPostorder =
    if postorder testTree == [1, 3, 2]
    then putStrLn "Postorder fine!"
    else putStrLn "postorder failed check"

quickTestPostorder = once $ postorder testTree == [1, 3, 2]

main1 :: IO ()
main1 = do
    testPreorder
    testInorder
    testPostorder

-- Write foldr for BinaryTree

-- any traversal order is fine
foldTree :: (a -> b -> b)
            -> b
            -> BinaryTree a
            -> b

foldTree f b Leaf = b
foldTree f b (Node left a right) = f a (foldTree f (foldTree f b left) right)
-- TODO check
